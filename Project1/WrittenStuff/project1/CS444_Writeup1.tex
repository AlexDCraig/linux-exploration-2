\documentclass[letterpaper,10pt,titlepage]{article}

\setlength{\parindent}{0pt}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

\usepackage{alltt}
\usepackage{float}
\usepackage{color}
\usepackage{url}
\usepackage{listings}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{geometry}
\geometry{textheight=8.5in, textwidth=6in}

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}
\usepackage{geometry}

\hypersetup{%
	colorlinks = true,
	linkcolor = black
}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\def\name{Alex Hoffer}

%pull in the necessary preamble matter for pygments output
\input{pygments.tex}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {CS444 ``Operating Systems''},
  pdftitle = {CS 444 Writeup 1},
  pdfsubject = {CS 444 Writeup 1},
  pdfpagemode = UseNone
}

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{3.5cm}

        \textbf{Writeup 1}

        \vspace{0.5cm}

        \textbf{Alex Hoffer}

        \vspace{0.8cm}

        CS 444\\
        Spring 2017\\

        \vspace{1cm}

        \textbf{Abstract}\\

        \vspace{0.5cm}

        This first write up describes important details from the completion of Project 1 for D. Kevin McGrath's Operating Systems II class. Topics from Project 1 that are to be covered in this work include the building of the Linux Yocto kernel on Oregon State's engineering server, usage of the qemu virtual machine, and a solution of the Producer-Consumer concurrency problem using the C programming language's POSIX threads execution model. 

        \vfill

    \end{center}
\end{titlepage}

\newpage

\tableofcontents

\newpage

\section{Log of Commands to Build Yocto Kernel}
\begin{lstlisting}
put code here
\end{lstlisting}

\section{Log of Commands to Load Qemu}

\section{Flags in the listed Qemu command line}
The listed Qemu command line is:
\begin{lstlisting}
qemu-system-i386 -gdb tcp::???? -S -nographic -kernel bzImage-qemux86.bin 
\end{lstlisting}
\begin{lstlisting}
-drive file=core-image-lsb-sdk-qemux86.ext3,if=virtio -enable-kvm 
\end{lstlisting}
\begin{lstlisting}
-net none -usb -localtime --no-reboot --append 
\end{lstlisting}
\begin{lstlisting}
"root=/dev/vda rw console=ttyS0 debug".
\end{lstlisting}

The following list describes each flag:
\begin{itemize}
\item \emph{-gdb} tells the system to wait to connect to gdb on the device tcp::????, this device being passed in as an argument.
\item \emph{-S} is a flag that tells the system to wait for a gdb connection.
\item \emph{-nographic} is a visualization option that turns off graphical output.
\item \emph{-kernel} is a flag that saves time and resources by granting the system a Linux kernel image, rather than requiring a full boot.
\item \emph{-drive} handles disk options and takes 1 to n number of arguments to specify these options, in the case of this command the file we passed to this flag is parsed according to the virtio interface.
\item \emph{-enable-kvm} is a flag that enables KVM virtualization support without any setting turned off.
\item \emph{-net} is a flag that sets network options.
\item \emph{-usb} is a flag that turns on the USB driver.
\item \emph{-localtime} is a flag that tells the system to use local time.
\item \emph{--no-reboot} tells the system to exit, not reboot, when rebooting is an option.
\item \emph{--append} is a flag that represents the command line necessary to interact with the kernel.
\end{itemize}

\section{Concurrency}
The following subsections answer the four questions as outlined on the Project 1 page on Kevin McGrath's course website.
\subsection{Main point of assignment}
There were several reasons for the assignment. One, I think, was to re-familiarize us with POSIX Threads, which we learned about in CS344 but likely forgot about before we got to this class. Second, I think that it was to teach us about the Producer-Consumer problem, which is a canonical example of concurrency. Third, it was to force us to use inline assembly language in our programs to help us learn how to implement ASM in C.
\subsection{Personal approach to problem}
My approach for the use of threads came from guidelines to the canonical Producer-Consumer problem that I found in the \emph{Linux Programming Interface} text. For example, statements like pthread\_create, pthread\_join, pthread\_t, pthread\_mutex\_t, and pthread\_cond\_t were all found in that book and that book instructed me on how to use them. I used these static pthread statements rather than dynamic ones because frankly, I could not think of a reason why dynamic ones would be necessary for the purposes of this assignment. My approach for the buffer and the item to be held in the buffer was just to use a struct to represent the buffer and a struct to represent the item and have the buffer hold a statically allocated array of pointers to items and for each item to have two data fields: a random number and a random waiting period, both that had to be implemented in ASM. Given the statements necessary to control threads and mutexes and the structs necessary to store data, I solved the problem by creating a thread to correspond to a Producer, having that Producer thread lock all of the shared data using a mutex and then produce a random item. After unlocking the shared data within the Producer thread, I created a Consumer thread that locked the data again, consumed the first non-null index in the buffer, and then unlocked the data again. I contained these Producer and Consumer thread creation statements in a forever loop (while(1)) so that when the program is run it is eternally creating producer and consumer threads and producing and consuming random data. 
\subsection{Ensuring solution was correct}
\subsection{What I learned}

\section{Version control log}

\section{Work log}

%\bibliographystyle{plain}
%\bibliography{CS444_Writeup1}
\end{document}
